import pygame
import sys
import random

# Cell types
GROUND, OBSTACLE, DRONE, BANDIT = "ground", "obstacle", "drone", "bandit"
CELL_SIZE, GRID_WIDTH, GRID_HEIGHT = 64, 10, 10

pygame.init()
screen = pygame.display.set_mode((CELL_SIZE * GRID_WIDTH, CELL_SIZE * GRID_HEIGHT))
pygame.display.set_caption("Swarm RL Simulation")

def load_and_resize(filename):
    img = pygame.image.load(filename).convert_alpha()
    return pygame.transform.smoothscale(img, (CELL_SIZE, CELL_SIZE))

ground_img = load_and_resize("Sprites/ground.png"); ground_img.set_alpha(120)
obstacle_img = load_and_resize("Sprites/Obstacle.png")
drone_img = load_and_resize("Sprites/drone.png")
bandit_img = load_and_resize("Sprites/bandit.png")

drones = [(2, 1), (7, 2), (0, 8), (6, 6), (9, 3)]
bandits = [(1, 5), (6, 0), (8, 7)]
obstacles = [
    (3, 3), (3, 4), (3, 5), (4, 3), (5, 3),
    (7, 5), (8, 5), (9, 5), (6, 7), (6, 8), (7, 8), (1, 7), (2, 7), (1, 8), (2, 8)
]
grid = [[GROUND for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]

for x, y in obstacles: grid[y][x] = OBSTACLE
for x, y in bandits: grid[y][x] = BANDIT

coverage = [[False for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
detected_bandits = set()

def draw_grid():
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            cell = grid[y][x]
            pos = (x * CELL_SIZE, y * CELL_SIZE)
            if cell == OBSTACLE:
                screen.blit(obstacle_img, pos)
            else:
                screen.blit(ground_img, pos)
                if cell == BANDIT:
                    screen.blit(bandit_img, pos)
    for drone_x, drone_y in drones:
        screen.blit(drone_img, (drone_x * CELL_SIZE, drone_y * CELL_SIZE))
    grid_color = (30, 30, 30)
    for x in range(GRID_WIDTH + 1):
        pygame.draw.line(screen, grid_color, (x * CELL_SIZE, 0), (x * CELL_SIZE, GRID_HEIGHT * CELL_SIZE), 1)
    for y in range(GRID_HEIGHT + 1):
        pygame.draw.line(screen, grid_color, (0, y * CELL_SIZE), (GRID_WIDTH * CELL_SIZE, y * CELL_SIZE), 1)

def available_moves(pos):
    x, y = pos
    moves = []
    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
        nx, ny = x+dx, y+dy
        if 0 <= nx < GRID_WIDTH and 0 <= ny < GRID_HEIGHT:
            if grid[ny][nx] != OBSTACLE and (nx, ny) not in drones:
                moves.append((nx, ny))
    return moves

def sense_bandits(drone_x, drone_y):
    seen_bandits = set()
    for dy in [-1,0,1]:
        for dx in [-1,0,1]:
            nx, ny = drone_x+dx, drone_y+dy
            if 0 <= nx < GRID_WIDTH and 0 <= ny < GRID_HEIGHT:
                if grid[ny][nx] == BANDIT and not is_obstacle_blocked(drone_x, drone_y, nx, ny):
                    seen_bandits.add((nx, ny))
    return seen_bandits

def is_obstacle_blocked(x0, y0, x1, y1):
    # Obstacle between (x0, y0) and (x1, y1) - direct line for adjacent cells
    if abs(x1-x0) > 1 or abs(y1-y0) > 1:
        return True
    # Check directly between - only for 3x3 field
    if grid[y1][x1] == OBSTACLE:
        return True
    # Optional extension: add LOS obstacle logic if needed
    return False

all_visited = False
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit(); sys.exit()

    if not all_visited:
        # Move each drone
        for i in range(len(drones)):
            x, y = drones[i]
            moves = available_moves((x, y))
            if moves:
                drones[i] = random.choice(moves)
        # Update coverage
        for drone_x, drone_y in drones:
            coverage[drone_y][drone_x] = True
            seen = sense_bandits(drone_x, drone_y)
            for b in seen:
                detected_bandits.add(b)
        # Check if all ground squares have been covered
        all_visited = all(
            coverage[y][x] or grid[y][x] == OBSTACLE
            for y in range(GRID_HEIGHT)
            for x in range(GRID_WIDTH)
        )

    draw_grid()
    # Optional: Show bandit count & coverage
    font = pygame.font.SysFont(None, 28)
    txt = font.render(f'Bandits detected: {len(detected_bandits)}', True, (255,0,0))
    screen.blit(txt, (10, 10))
    pygame.display.update()
    clock.tick(5)  # 5 steps per second for visible movement
